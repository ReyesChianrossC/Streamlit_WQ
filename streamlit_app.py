# -*- coding: utf-8 -*-
"""Streamlit App for Water Quality Predictions

This app loads precomputed predictions from a parquet file and allows users to filter and view them.
"""

import streamlit as st
import pandas as pd
import numpy as np
import os

# Set page configuration
st.set_page_config(page_title="Water Quality Prediction Dashboard", layout="wide")

# Title and description
st.title("Water Quality Prediction Dashboard")
st.markdown("""
This dashboard displays water quality predictions generated by different models (CNN, LSTM, CNN-LSTM) for various time horizons.
Select a site and prediction horizon to view and compare predictions across models.
""")

# File path for precomputed predictions
SITE_PREDICTIONS_PATH = "site_predictions.parquet"

# Check if the predictions file exists
if not os.path.exists(SITE_PREDICTIONS_PATH):
    st.error(f"Prediction file not found at {SITE_PREDICTIONS_PATH}. Please ensure the model prediction script has been run to generate the file.")
    st.stop()

# Load precomputed predictions
try:
    site_predictions = pd.read_parquet(SITE_PREDICTIONS_PATH)
except Exception as e:
    st.error(f"Error loading predictions: {e}")
    st.stop()

# Extract unique sites, models, and horizons
unique_sites = site_predictions['site'].dropna().unique()
unique_models = site_predictions['model'].unique()
unique_horizons = site_predictions['horizon'].unique()

# Sidebar for filtering
st.sidebar.header("Filter Options")
selected_site = st.sidebar.selectbox("Select Site", options=unique_sites)
selected_horizon = st.sidebar.selectbox("Select Prediction Horizon", options=unique_horizons)

# Filter predictions based on site and horizon
filtered_predictions = site_predictions[
    (site_predictions['site'] == selected_site) &
    (site_predictions['horizon'] == selected_horizon)
]

# Display predictions
if not filtered_predictions.empty:
    st.header(f"Predictions for {selected_site} ({selected_horizon})")

    # Extract prediction columns (e.g., pred_ammonia, pred_nitrate, etc.)
    pred_columns = [col for col in filtered_predictions.columns if col.startswith('pred_')]

    # Comparison table across models
    st.subheader("Comparison Across Models")
    comparison_df = filtered_predictions.pivot_table(
        index='index',
        columns='model',
        values=pred_columns,
        aggfunc='first'
    ).reset_index()

    # Flatten multi-level columns for display
    comparison_df.columns = ['index'] + [f"{model}_{param}" for param, model in comparison_df.columns[1:]]

    # Compute variance across models for each parameter
    variance_data = {}
    for param in pred_columns:
        param_cols = [col for col in comparison_df.columns if col.startswith(param.replace('pred_', ''))]
        if param_cols:
            param_values = comparison_df[param_cols].values
            variance_data[param.replace('pred_', '')] = np.std(param_values, axis=1).mean()

    st.write("**Average Variance of Predictions Across Models (per parameter):**")
    st.write(pd.Series(variance_data))

    # Display the comparison table
    display_comparison_df = comparison_df.drop(columns=['index'])
    display_comparison_df.columns = [col.replace('pred_', '').replace('_', ' ').title() for col in display_comparison_df.columns]
    st.dataframe(display_comparison_df, use_container_width=True)

    # Download button for comparison data
    csv = display_comparison_df.to_csv(index=False)
    st.download_button(
        label="Download Comparison Data as CSV",
        data=csv,
        file_name=f"predictions_{selected_site}_{selected_horizon}.csv",
        mime="text/csv"
    )

    # Detailed view for a single model
    st.subheader("Detailed View for a Selected Model")
    selected_model = st.selectbox("Select Model to View Details", options=unique_models)
    model_filtered = filtered_predictions[filtered_predictions['model'] == selected_model]

    if not model_filtered.empty:
        # Compute prediction variance for the selected model
        pred_values = model_filtered[pred_columns].values
        pred_std = np.std(pred_values, axis=0)
        st.write(f"**Prediction Variance (std) for {selected_model}:** {pred_std}")

        # Display predictions in a table
        display_df = model_filtered[pred_columns].reset_index(drop=True)
        display_df.columns = [col.replace('pred_', '').replace('_', ' ').title() for col in display_df.columns]

        col1, col2 = st.columns(2)
        with col1:
            st.write("**Water Quality Parameters**")
            st.dataframe(display_df, use_container_width=True)

        with col2:
            st.write("**Summary Statistics**")
            st.write("Mean Predictions:")
            st.write(display_df.mean().to_frame().T)
            st.write("Standard Deviation:")
            st.write(display_df.std().to_frame().T)
    else:
        st.warning(f"No predictions available for {selected_model} at this site and horizon.")

else:
    st.warning("No predictions available for the selected site and horizon. Please try a different combination.")

# Footer
st.markdown("---")
st.markdown("Developed with Streamlit | Data Source: Precomputed predictions from model_prediction.py")
